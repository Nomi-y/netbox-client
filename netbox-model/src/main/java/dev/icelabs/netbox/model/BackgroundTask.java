/*
 * NetBox REST API
 * No description provided (generated by Openapi Generator https://github.com/openapitools/openapi-generator)
 *
 * The version of the OpenAPI document: 4.5.2-Docker-4.0.0 (4.5)
 * 
 *
 * NOTE: This class is auto generated by OpenAPI Generator (https://openapi-generator.tech).
 * https://openapi-generator.tech
 * Do not edit the class manually.
 */


package dev.icelabs.netbox.model;

import java.util.Objects;
import java.util.Arrays;
import com.google.gson.TypeAdapter;
import com.google.gson.annotations.JsonAdapter;
import com.google.gson.annotations.SerializedName;
import com.google.gson.stream.JsonReader;
import com.google.gson.stream.JsonWriter;
import java.io.IOException;
import java.net.URI;
import java.time.OffsetDateTime;
import java.util.ArrayList;
import java.util.Arrays;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.io.Serializable;
import java.io.UnsupportedEncodingException;
import java.net.URLEncoder;
import java.util.StringJoiner;

/**
 * BackgroundTask
 */
@javax.annotation.Generated(value = "org.openapitools.codegen.languages.JavaClientCodegen", comments = "Generator version: 7.20.0-SNAPSHOT")
public class BackgroundTask implements Serializable {
  private static final long serialVersionUID = 1L;

  public static final String SERIALIZED_NAME_ID = "id";
  @SerializedName(SERIALIZED_NAME_ID)
  @javax.annotation.Nonnull
  private String id;

  public static final String SERIALIZED_NAME_URL = "url";
  @SerializedName(SERIALIZED_NAME_URL)
  @javax.annotation.Nonnull
  private URI url;

  public static final String SERIALIZED_NAME_DESCRIPTION = "description";
  @SerializedName(SERIALIZED_NAME_DESCRIPTION)
  @javax.annotation.Nonnull
  private String description;

  public static final String SERIALIZED_NAME_ORIGIN = "origin";
  @SerializedName(SERIALIZED_NAME_ORIGIN)
  @javax.annotation.Nonnull
  private String origin;

  public static final String SERIALIZED_NAME_FUNC_NAME = "func_name";
  @SerializedName(SERIALIZED_NAME_FUNC_NAME)
  @javax.annotation.Nonnull
  private String funcName;

  public static final String SERIALIZED_NAME_ARGS = "args";
  @SerializedName(SERIALIZED_NAME_ARGS)
  @javax.annotation.Nonnull
  private List<Object> args = new ArrayList<>();

  public static final String SERIALIZED_NAME_KWARGS = "kwargs";
  @SerializedName(SERIALIZED_NAME_KWARGS)
  @javax.annotation.Nonnull
  private Map<String, Object> kwargs = new HashMap<>();

  public static final String SERIALIZED_NAME_RESULT = "result";
  @SerializedName(SERIALIZED_NAME_RESULT)
  @javax.annotation.Nonnull
  private String result;

  public static final String SERIALIZED_NAME_TIMEOUT = "timeout";
  @SerializedName(SERIALIZED_NAME_TIMEOUT)
  @javax.annotation.Nonnull
  private Integer timeout;

  public static final String SERIALIZED_NAME_RESULT_TTL = "result_ttl";
  @SerializedName(SERIALIZED_NAME_RESULT_TTL)
  @javax.annotation.Nonnull
  private Integer resultTtl;

  public static final String SERIALIZED_NAME_CREATED_AT = "created_at";
  @SerializedName(SERIALIZED_NAME_CREATED_AT)
  @javax.annotation.Nonnull
  private OffsetDateTime createdAt;

  public static final String SERIALIZED_NAME_ENQUEUED_AT = "enqueued_at";
  @SerializedName(SERIALIZED_NAME_ENQUEUED_AT)
  @javax.annotation.Nonnull
  private OffsetDateTime enqueuedAt;

  public static final String SERIALIZED_NAME_STARTED_AT = "started_at";
  @SerializedName(SERIALIZED_NAME_STARTED_AT)
  @javax.annotation.Nonnull
  private OffsetDateTime startedAt;

  public static final String SERIALIZED_NAME_ENDED_AT = "ended_at";
  @SerializedName(SERIALIZED_NAME_ENDED_AT)
  @javax.annotation.Nonnull
  private OffsetDateTime endedAt;

  public static final String SERIALIZED_NAME_WORKER_NAME = "worker_name";
  @SerializedName(SERIALIZED_NAME_WORKER_NAME)
  @javax.annotation.Nonnull
  private String workerName;

  public static final String SERIALIZED_NAME_POSITION = "position";
  @SerializedName(SERIALIZED_NAME_POSITION)
  @javax.annotation.Nonnull
  private Integer position;

  public static final String SERIALIZED_NAME_STATUS = "status";
  @SerializedName(SERIALIZED_NAME_STATUS)
  @javax.annotation.Nonnull
  private String status;

  public static final String SERIALIZED_NAME_META = "meta";
  @SerializedName(SERIALIZED_NAME_META)
  @javax.annotation.Nonnull
  private Map<String, Object> meta = new HashMap<>();

  public static final String SERIALIZED_NAME_LAST_HEARTBEAT = "last_heartbeat";
  @SerializedName(SERIALIZED_NAME_LAST_HEARTBEAT)
  @javax.annotation.Nonnull
  private String lastHeartbeat;

  public static final String SERIALIZED_NAME_IS_FINISHED = "is_finished";
  @SerializedName(SERIALIZED_NAME_IS_FINISHED)
  @javax.annotation.Nonnull
  private Boolean isFinished;

  public static final String SERIALIZED_NAME_IS_QUEUED = "is_queued";
  @SerializedName(SERIALIZED_NAME_IS_QUEUED)
  @javax.annotation.Nonnull
  private Boolean isQueued;

  public static final String SERIALIZED_NAME_IS_FAILED = "is_failed";
  @SerializedName(SERIALIZED_NAME_IS_FAILED)
  @javax.annotation.Nonnull
  private Boolean isFailed;

  public static final String SERIALIZED_NAME_IS_STARTED = "is_started";
  @SerializedName(SERIALIZED_NAME_IS_STARTED)
  @javax.annotation.Nonnull
  private Boolean isStarted;

  public static final String SERIALIZED_NAME_IS_DEFERRED = "is_deferred";
  @SerializedName(SERIALIZED_NAME_IS_DEFERRED)
  @javax.annotation.Nonnull
  private Boolean isDeferred;

  public static final String SERIALIZED_NAME_IS_CANCELED = "is_canceled";
  @SerializedName(SERIALIZED_NAME_IS_CANCELED)
  @javax.annotation.Nonnull
  private Boolean isCanceled;

  public static final String SERIALIZED_NAME_IS_SCHEDULED = "is_scheduled";
  @SerializedName(SERIALIZED_NAME_IS_SCHEDULED)
  @javax.annotation.Nonnull
  private Boolean isScheduled;

  public static final String SERIALIZED_NAME_IS_STOPPED = "is_stopped";
  @SerializedName(SERIALIZED_NAME_IS_STOPPED)
  @javax.annotation.Nonnull
  private Boolean isStopped;

  public BackgroundTask() {
  }
  /**
   * Constructor with only readonly parameters
   */
  
  public BackgroundTask(
     URI url, 
     List<Object> args, 
     Map<String, Object> kwargs, 
     Integer position, 
     String status
  ) {
    this();
    this.url = url;
    this.args = args;
    this.kwargs = kwargs;
    this.position = position;
    this.status = status;
  }

  public BackgroundTask id(@javax.annotation.Nonnull String id) {
    
    this.id = id;
    return this;
  }

  /**
   * Get id
   * @return id
   */
  @javax.annotation.Nonnull

  public String getId() {
    return id;
  }


  public void setId(@javax.annotation.Nonnull String id) {
    this.id = id;
  }

  /**
   * Get url
   * @return url
   */
  @javax.annotation.Nonnull

  public URI getUrl() {
    return url;
  }



  public BackgroundTask description(@javax.annotation.Nonnull String description) {
    
    this.description = description;
    return this;
  }

  /**
   * Get description
   * @return description
   */
  @javax.annotation.Nonnull

  public String getDescription() {
    return description;
  }


  public void setDescription(@javax.annotation.Nonnull String description) {
    this.description = description;
  }

  public BackgroundTask origin(@javax.annotation.Nonnull String origin) {
    
    this.origin = origin;
    return this;
  }

  /**
   * Get origin
   * @return origin
   */
  @javax.annotation.Nonnull

  public String getOrigin() {
    return origin;
  }


  public void setOrigin(@javax.annotation.Nonnull String origin) {
    this.origin = origin;
  }

  public BackgroundTask funcName(@javax.annotation.Nonnull String funcName) {
    
    this.funcName = funcName;
    return this;
  }

  /**
   * Get funcName
   * @return funcName
   */
  @javax.annotation.Nonnull

  public String getFuncName() {
    return funcName;
  }


  public void setFuncName(@javax.annotation.Nonnull String funcName) {
    this.funcName = funcName;
  }

  /**
   * Get args
   * @return args
   */
  @javax.annotation.Nonnull

  public List<Object> getArgs() {
    return args;
  }



  /**
   * Get kwargs
   * @return kwargs
   */
  @javax.annotation.Nonnull

  public Map<String, Object> getKwargs() {
    return kwargs;
  }



  public BackgroundTask result(@javax.annotation.Nonnull String result) {
    
    this.result = result;
    return this;
  }

  /**
   * Get result
   * @return result
   */
  @javax.annotation.Nonnull

  public String getResult() {
    return result;
  }


  public void setResult(@javax.annotation.Nonnull String result) {
    this.result = result;
  }

  public BackgroundTask timeout(@javax.annotation.Nonnull Integer timeout) {
    
    this.timeout = timeout;
    return this;
  }

  /**
   * Get timeout
   * @return timeout
   */
  @javax.annotation.Nonnull

  public Integer getTimeout() {
    return timeout;
  }


  public void setTimeout(@javax.annotation.Nonnull Integer timeout) {
    this.timeout = timeout;
  }

  public BackgroundTask resultTtl(@javax.annotation.Nonnull Integer resultTtl) {
    
    this.resultTtl = resultTtl;
    return this;
  }

  /**
   * Get resultTtl
   * @return resultTtl
   */
  @javax.annotation.Nonnull

  public Integer getResultTtl() {
    return resultTtl;
  }


  public void setResultTtl(@javax.annotation.Nonnull Integer resultTtl) {
    this.resultTtl = resultTtl;
  }

  public BackgroundTask createdAt(@javax.annotation.Nonnull OffsetDateTime createdAt) {
    
    this.createdAt = createdAt;
    return this;
  }

  /**
   * Get createdAt
   * @return createdAt
   */
  @javax.annotation.Nonnull

  public OffsetDateTime getCreatedAt() {
    return createdAt;
  }


  public void setCreatedAt(@javax.annotation.Nonnull OffsetDateTime createdAt) {
    this.createdAt = createdAt;
  }

  public BackgroundTask enqueuedAt(@javax.annotation.Nonnull OffsetDateTime enqueuedAt) {
    
    this.enqueuedAt = enqueuedAt;
    return this;
  }

  /**
   * Get enqueuedAt
   * @return enqueuedAt
   */
  @javax.annotation.Nonnull

  public OffsetDateTime getEnqueuedAt() {
    return enqueuedAt;
  }


  public void setEnqueuedAt(@javax.annotation.Nonnull OffsetDateTime enqueuedAt) {
    this.enqueuedAt = enqueuedAt;
  }

  public BackgroundTask startedAt(@javax.annotation.Nonnull OffsetDateTime startedAt) {
    
    this.startedAt = startedAt;
    return this;
  }

  /**
   * Get startedAt
   * @return startedAt
   */
  @javax.annotation.Nonnull

  public OffsetDateTime getStartedAt() {
    return startedAt;
  }


  public void setStartedAt(@javax.annotation.Nonnull OffsetDateTime startedAt) {
    this.startedAt = startedAt;
  }

  public BackgroundTask endedAt(@javax.annotation.Nonnull OffsetDateTime endedAt) {
    
    this.endedAt = endedAt;
    return this;
  }

  /**
   * Get endedAt
   * @return endedAt
   */
  @javax.annotation.Nonnull

  public OffsetDateTime getEndedAt() {
    return endedAt;
  }


  public void setEndedAt(@javax.annotation.Nonnull OffsetDateTime endedAt) {
    this.endedAt = endedAt;
  }

  public BackgroundTask workerName(@javax.annotation.Nonnull String workerName) {
    
    this.workerName = workerName;
    return this;
  }

  /**
   * Get workerName
   * @return workerName
   */
  @javax.annotation.Nonnull

  public String getWorkerName() {
    return workerName;
  }


  public void setWorkerName(@javax.annotation.Nonnull String workerName) {
    this.workerName = workerName;
  }

  /**
   * Get position
   * @return position
   */
  @javax.annotation.Nonnull

  public Integer getPosition() {
    return position;
  }



  /**
   * Get status
   * @return status
   */
  @javax.annotation.Nonnull

  public String getStatus() {
    return status;
  }



  public BackgroundTask meta(@javax.annotation.Nonnull Map<String, Object> meta) {
    
    this.meta = meta;
    return this;
  }

  public BackgroundTask putMetaItem(String key, Object metaItem) {
    this.meta.put(key, metaItem);
    return this;
  }

  /**
   * Get meta
   * @return meta
   */
  @javax.annotation.Nonnull

  public Map<String, Object> getMeta() {
    return meta;
  }


  public void setMeta(@javax.annotation.Nonnull Map<String, Object> meta) {
    this.meta = meta;
  }

  public BackgroundTask lastHeartbeat(@javax.annotation.Nonnull String lastHeartbeat) {
    
    this.lastHeartbeat = lastHeartbeat;
    return this;
  }

  /**
   * Get lastHeartbeat
   * @return lastHeartbeat
   */
  @javax.annotation.Nonnull

  public String getLastHeartbeat() {
    return lastHeartbeat;
  }


  public void setLastHeartbeat(@javax.annotation.Nonnull String lastHeartbeat) {
    this.lastHeartbeat = lastHeartbeat;
  }

  public BackgroundTask isFinished(@javax.annotation.Nonnull Boolean isFinished) {
    
    this.isFinished = isFinished;
    return this;
  }

  /**
   * Get isFinished
   * @return isFinished
   */
  @javax.annotation.Nonnull

  public Boolean getIsFinished() {
    return isFinished;
  }


  public void setIsFinished(@javax.annotation.Nonnull Boolean isFinished) {
    this.isFinished = isFinished;
  }

  public BackgroundTask isQueued(@javax.annotation.Nonnull Boolean isQueued) {
    
    this.isQueued = isQueued;
    return this;
  }

  /**
   * Get isQueued
   * @return isQueued
   */
  @javax.annotation.Nonnull

  public Boolean getIsQueued() {
    return isQueued;
  }


  public void setIsQueued(@javax.annotation.Nonnull Boolean isQueued) {
    this.isQueued = isQueued;
  }

  public BackgroundTask isFailed(@javax.annotation.Nonnull Boolean isFailed) {
    
    this.isFailed = isFailed;
    return this;
  }

  /**
   * Get isFailed
   * @return isFailed
   */
  @javax.annotation.Nonnull

  public Boolean getIsFailed() {
    return isFailed;
  }


  public void setIsFailed(@javax.annotation.Nonnull Boolean isFailed) {
    this.isFailed = isFailed;
  }

  public BackgroundTask isStarted(@javax.annotation.Nonnull Boolean isStarted) {
    
    this.isStarted = isStarted;
    return this;
  }

  /**
   * Get isStarted
   * @return isStarted
   */
  @javax.annotation.Nonnull

  public Boolean getIsStarted() {
    return isStarted;
  }


  public void setIsStarted(@javax.annotation.Nonnull Boolean isStarted) {
    this.isStarted = isStarted;
  }

  public BackgroundTask isDeferred(@javax.annotation.Nonnull Boolean isDeferred) {
    
    this.isDeferred = isDeferred;
    return this;
  }

  /**
   * Get isDeferred
   * @return isDeferred
   */
  @javax.annotation.Nonnull

  public Boolean getIsDeferred() {
    return isDeferred;
  }


  public void setIsDeferred(@javax.annotation.Nonnull Boolean isDeferred) {
    this.isDeferred = isDeferred;
  }

  public BackgroundTask isCanceled(@javax.annotation.Nonnull Boolean isCanceled) {
    
    this.isCanceled = isCanceled;
    return this;
  }

  /**
   * Get isCanceled
   * @return isCanceled
   */
  @javax.annotation.Nonnull

  public Boolean getIsCanceled() {
    return isCanceled;
  }


  public void setIsCanceled(@javax.annotation.Nonnull Boolean isCanceled) {
    this.isCanceled = isCanceled;
  }

  public BackgroundTask isScheduled(@javax.annotation.Nonnull Boolean isScheduled) {
    
    this.isScheduled = isScheduled;
    return this;
  }

  /**
   * Get isScheduled
   * @return isScheduled
   */
  @javax.annotation.Nonnull

  public Boolean getIsScheduled() {
    return isScheduled;
  }


  public void setIsScheduled(@javax.annotation.Nonnull Boolean isScheduled) {
    this.isScheduled = isScheduled;
  }

  public BackgroundTask isStopped(@javax.annotation.Nonnull Boolean isStopped) {
    
    this.isStopped = isStopped;
    return this;
  }

  /**
   * Get isStopped
   * @return isStopped
   */
  @javax.annotation.Nonnull

  public Boolean getIsStopped() {
    return isStopped;
  }


  public void setIsStopped(@javax.annotation.Nonnull Boolean isStopped) {
    this.isStopped = isStopped;
  }


  @Override
  public boolean equals(Object o) {
    if (this == o) {
      return true;
    }
    if (o == null || getClass() != o.getClass()) {
      return false;
    }
    BackgroundTask backgroundTask = (BackgroundTask) o;
    return Objects.equals(this.id, backgroundTask.id) &&
        Objects.equals(this.url, backgroundTask.url) &&
        Objects.equals(this.description, backgroundTask.description) &&
        Objects.equals(this.origin, backgroundTask.origin) &&
        Objects.equals(this.funcName, backgroundTask.funcName) &&
        Objects.equals(this.args, backgroundTask.args) &&
        Objects.equals(this.kwargs, backgroundTask.kwargs) &&
        Objects.equals(this.result, backgroundTask.result) &&
        Objects.equals(this.timeout, backgroundTask.timeout) &&
        Objects.equals(this.resultTtl, backgroundTask.resultTtl) &&
        Objects.equals(this.createdAt, backgroundTask.createdAt) &&
        Objects.equals(this.enqueuedAt, backgroundTask.enqueuedAt) &&
        Objects.equals(this.startedAt, backgroundTask.startedAt) &&
        Objects.equals(this.endedAt, backgroundTask.endedAt) &&
        Objects.equals(this.workerName, backgroundTask.workerName) &&
        Objects.equals(this.position, backgroundTask.position) &&
        Objects.equals(this.status, backgroundTask.status) &&
        Objects.equals(this.meta, backgroundTask.meta) &&
        Objects.equals(this.lastHeartbeat, backgroundTask.lastHeartbeat) &&
        Objects.equals(this.isFinished, backgroundTask.isFinished) &&
        Objects.equals(this.isQueued, backgroundTask.isQueued) &&
        Objects.equals(this.isFailed, backgroundTask.isFailed) &&
        Objects.equals(this.isStarted, backgroundTask.isStarted) &&
        Objects.equals(this.isDeferred, backgroundTask.isDeferred) &&
        Objects.equals(this.isCanceled, backgroundTask.isCanceled) &&
        Objects.equals(this.isScheduled, backgroundTask.isScheduled) &&
        Objects.equals(this.isStopped, backgroundTask.isStopped);
  }

  @Override
  public int hashCode() {
    return Objects.hash(id, url, description, origin, funcName, args, kwargs, result, timeout, resultTtl, createdAt, enqueuedAt, startedAt, endedAt, workerName, position, status, meta, lastHeartbeat, isFinished, isQueued, isFailed, isStarted, isDeferred, isCanceled, isScheduled, isStopped);
  }

  @Override
  public String toString() {
    StringBuilder sb = new StringBuilder();
    sb.append("class BackgroundTask {\n");
    sb.append("    id: ").append(toIndentedString(id)).append("\n");
    sb.append("    url: ").append(toIndentedString(url)).append("\n");
    sb.append("    description: ").append(toIndentedString(description)).append("\n");
    sb.append("    origin: ").append(toIndentedString(origin)).append("\n");
    sb.append("    funcName: ").append(toIndentedString(funcName)).append("\n");
    sb.append("    args: ").append(toIndentedString(args)).append("\n");
    sb.append("    kwargs: ").append(toIndentedString(kwargs)).append("\n");
    sb.append("    result: ").append(toIndentedString(result)).append("\n");
    sb.append("    timeout: ").append(toIndentedString(timeout)).append("\n");
    sb.append("    resultTtl: ").append(toIndentedString(resultTtl)).append("\n");
    sb.append("    createdAt: ").append(toIndentedString(createdAt)).append("\n");
    sb.append("    enqueuedAt: ").append(toIndentedString(enqueuedAt)).append("\n");
    sb.append("    startedAt: ").append(toIndentedString(startedAt)).append("\n");
    sb.append("    endedAt: ").append(toIndentedString(endedAt)).append("\n");
    sb.append("    workerName: ").append(toIndentedString(workerName)).append("\n");
    sb.append("    position: ").append(toIndentedString(position)).append("\n");
    sb.append("    status: ").append(toIndentedString(status)).append("\n");
    sb.append("    meta: ").append(toIndentedString(meta)).append("\n");
    sb.append("    lastHeartbeat: ").append(toIndentedString(lastHeartbeat)).append("\n");
    sb.append("    isFinished: ").append(toIndentedString(isFinished)).append("\n");
    sb.append("    isQueued: ").append(toIndentedString(isQueued)).append("\n");
    sb.append("    isFailed: ").append(toIndentedString(isFailed)).append("\n");
    sb.append("    isStarted: ").append(toIndentedString(isStarted)).append("\n");
    sb.append("    isDeferred: ").append(toIndentedString(isDeferred)).append("\n");
    sb.append("    isCanceled: ").append(toIndentedString(isCanceled)).append("\n");
    sb.append("    isScheduled: ").append(toIndentedString(isScheduled)).append("\n");
    sb.append("    isStopped: ").append(toIndentedString(isStopped)).append("\n");
    sb.append("}");
    return sb.toString();
  }

  /**
   * Convert the given object to string with each line indented by 4 spaces
   * (except the first line).
   */
  private String toIndentedString(Object o) {
    if (o == null) {
      return "null";
    }
    return o.toString().replace("\n", "\n    ");
  }

  /**
   * Convert the instance into URL query string.
   *
   * @return URL query string
   */
  public String toUrlQueryString() {
    return toUrlQueryString(null);
  }

  /**
   * Convert the instance into URL query string.
   *
   * @param prefix prefix of the query string
   * @return URL query string
   */
  public String toUrlQueryString(String prefix) {
    String suffix = "";
    String containerSuffix = "";
    String containerPrefix = "";
    if (prefix == null) {
      // style=form, explode=true, e.g. /pet?name=cat&type=manx
      prefix = "";
    } else {
      // deepObject style e.g. /pet?id[name]=cat&id[type]=manx
      prefix = prefix + "[";
      suffix = "]";
      containerSuffix = "]";
      containerPrefix = "[";
    }

    StringJoiner joiner = new StringJoiner("&");

    // add `id` to the URL query string
    if (getId() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sid%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getId()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `url` to the URL query string
    if (getUrl() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%surl%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getUrl()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `description` to the URL query string
    if (getDescription() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sdescription%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getDescription()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `origin` to the URL query string
    if (getOrigin() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sorigin%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getOrigin()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `func_name` to the URL query string
    if (getFuncName() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sfunc_name%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getFuncName()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `args` to the URL query string
    if (getArgs() != null) {
      for (int i = 0; i < getArgs().size(); i++) {
        try {
          joiner.add(String.format(java.util.Locale.ROOT, "%sargs%s%s=%s", prefix, suffix,
              "".equals(suffix) ? "" : String.format(java.util.Locale.ROOT, "%s%d%s", containerPrefix, i, containerSuffix),
              URLEncoder.encode(String.valueOf(getArgs().get(i)), "UTF-8").replaceAll("\\+", "%20")));
        } catch (UnsupportedEncodingException e) {
          // Should never happen, UTF-8 is always supported
          throw new RuntimeException(e);
        }
      }
    }

    // add `kwargs` to the URL query string
    if (getKwargs() != null) {
      for (String _key : getKwargs().keySet()) {
        try {
          joiner.add(String.format(java.util.Locale.ROOT, "%skwargs%s%s=%s", prefix, suffix,
              "".equals(suffix) ? "" : String.format(java.util.Locale.ROOT, "%s%d%s", containerPrefix, _key, containerSuffix),
              getKwargs().get(_key), URLEncoder.encode(String.valueOf(getKwargs().get(_key)), "UTF-8").replaceAll("\\+", "%20")));
        } catch (UnsupportedEncodingException e) {
          // Should never happen, UTF-8 is always supported
          throw new RuntimeException(e);
        }
      }
    }

    // add `result` to the URL query string
    if (getResult() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sresult%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getResult()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `timeout` to the URL query string
    if (getTimeout() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%stimeout%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getTimeout()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `result_ttl` to the URL query string
    if (getResultTtl() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sresult_ttl%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getResultTtl()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `created_at` to the URL query string
    if (getCreatedAt() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%screated_at%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getCreatedAt()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `enqueued_at` to the URL query string
    if (getEnqueuedAt() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%senqueued_at%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getEnqueuedAt()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `started_at` to the URL query string
    if (getStartedAt() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sstarted_at%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getStartedAt()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `ended_at` to the URL query string
    if (getEndedAt() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sended_at%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getEndedAt()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `worker_name` to the URL query string
    if (getWorkerName() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sworker_name%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getWorkerName()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `position` to the URL query string
    if (getPosition() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sposition%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getPosition()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `status` to the URL query string
    if (getStatus() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sstatus%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getStatus()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `meta` to the URL query string
    if (getMeta() != null) {
      for (String _key : getMeta().keySet()) {
        try {
          joiner.add(String.format(java.util.Locale.ROOT, "%smeta%s%s=%s", prefix, suffix,
              "".equals(suffix) ? "" : String.format(java.util.Locale.ROOT, "%s%d%s", containerPrefix, _key, containerSuffix),
              getMeta().get(_key), URLEncoder.encode(String.valueOf(getMeta().get(_key)), "UTF-8").replaceAll("\\+", "%20")));
        } catch (UnsupportedEncodingException e) {
          // Should never happen, UTF-8 is always supported
          throw new RuntimeException(e);
        }
      }
    }

    // add `last_heartbeat` to the URL query string
    if (getLastHeartbeat() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%slast_heartbeat%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getLastHeartbeat()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `is_finished` to the URL query string
    if (getIsFinished() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sis_finished%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getIsFinished()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `is_queued` to the URL query string
    if (getIsQueued() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sis_queued%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getIsQueued()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `is_failed` to the URL query string
    if (getIsFailed() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sis_failed%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getIsFailed()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `is_started` to the URL query string
    if (getIsStarted() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sis_started%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getIsStarted()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `is_deferred` to the URL query string
    if (getIsDeferred() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sis_deferred%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getIsDeferred()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `is_canceled` to the URL query string
    if (getIsCanceled() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sis_canceled%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getIsCanceled()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `is_scheduled` to the URL query string
    if (getIsScheduled() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sis_scheduled%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getIsScheduled()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    // add `is_stopped` to the URL query string
    if (getIsStopped() != null) {
      try {
        joiner.add(String.format(java.util.Locale.ROOT, "%sis_stopped%s=%s", prefix, suffix, URLEncoder.encode(String.valueOf(getIsStopped()), "UTF-8").replaceAll("\\+", "%20")));
      } catch (UnsupportedEncodingException e) {
        // Should never happen, UTF-8 is always supported
        throw new RuntimeException(e);
      }
    }

    return joiner.toString();
  }

  public static class Builder {

    private BackgroundTask instance;

    public Builder() {
      this(new BackgroundTask());
    }

    protected Builder(BackgroundTask instance) {
      this.instance = instance;
    }

    public BackgroundTask.Builder id(String id) {
      this.instance.id = id;
      return this;
    }
    public BackgroundTask.Builder url(URI url) {
      this.instance.url = url;
      return this;
    }
    public BackgroundTask.Builder description(String description) {
      this.instance.description = description;
      return this;
    }
    public BackgroundTask.Builder origin(String origin) {
      this.instance.origin = origin;
      return this;
    }
    public BackgroundTask.Builder funcName(String funcName) {
      this.instance.funcName = funcName;
      return this;
    }
    public BackgroundTask.Builder args(List<Object> args) {
      this.instance.args = args;
      return this;
    }
    public BackgroundTask.Builder kwargs(Map<String, Object> kwargs) {
      this.instance.kwargs = kwargs;
      return this;
    }
    public BackgroundTask.Builder result(String result) {
      this.instance.result = result;
      return this;
    }
    public BackgroundTask.Builder timeout(Integer timeout) {
      this.instance.timeout = timeout;
      return this;
    }
    public BackgroundTask.Builder resultTtl(Integer resultTtl) {
      this.instance.resultTtl = resultTtl;
      return this;
    }
    public BackgroundTask.Builder createdAt(OffsetDateTime createdAt) {
      this.instance.createdAt = createdAt;
      return this;
    }
    public BackgroundTask.Builder enqueuedAt(OffsetDateTime enqueuedAt) {
      this.instance.enqueuedAt = enqueuedAt;
      return this;
    }
    public BackgroundTask.Builder startedAt(OffsetDateTime startedAt) {
      this.instance.startedAt = startedAt;
      return this;
    }
    public BackgroundTask.Builder endedAt(OffsetDateTime endedAt) {
      this.instance.endedAt = endedAt;
      return this;
    }
    public BackgroundTask.Builder workerName(String workerName) {
      this.instance.workerName = workerName;
      return this;
    }
    public BackgroundTask.Builder position(Integer position) {
      this.instance.position = position;
      return this;
    }
    public BackgroundTask.Builder status(String status) {
      this.instance.status = status;
      return this;
    }
    public BackgroundTask.Builder meta(Map<String, Object> meta) {
      this.instance.meta = meta;
      return this;
    }
    public BackgroundTask.Builder lastHeartbeat(String lastHeartbeat) {
      this.instance.lastHeartbeat = lastHeartbeat;
      return this;
    }
    public BackgroundTask.Builder isFinished(Boolean isFinished) {
      this.instance.isFinished = isFinished;
      return this;
    }
    public BackgroundTask.Builder isQueued(Boolean isQueued) {
      this.instance.isQueued = isQueued;
      return this;
    }
    public BackgroundTask.Builder isFailed(Boolean isFailed) {
      this.instance.isFailed = isFailed;
      return this;
    }
    public BackgroundTask.Builder isStarted(Boolean isStarted) {
      this.instance.isStarted = isStarted;
      return this;
    }
    public BackgroundTask.Builder isDeferred(Boolean isDeferred) {
      this.instance.isDeferred = isDeferred;
      return this;
    }
    public BackgroundTask.Builder isCanceled(Boolean isCanceled) {
      this.instance.isCanceled = isCanceled;
      return this;
    }
    public BackgroundTask.Builder isScheduled(Boolean isScheduled) {
      this.instance.isScheduled = isScheduled;
      return this;
    }
    public BackgroundTask.Builder isStopped(Boolean isStopped) {
      this.instance.isStopped = isStopped;
      return this;
    }


    /**
    * returns a built BackgroundTask instance.
    *
    * The builder is not reusable.
    */
    public BackgroundTask build() {
      try {
        return this.instance;
      } finally {
        // ensure that this.instance is not reused
        this.instance = null;
      }
    }

    @Override
    public String toString() {
      return getClass() + "=(" + instance + ")";
    }
  }

  /**
  * Create a builder with no initialized field.
  */
  public static BackgroundTask.Builder builder() {
    return new BackgroundTask.Builder();
  }

  /**
  * Create a builder with a shallow copy of this instance.
  */
  public BackgroundTask.Builder toBuilder() {
    return new BackgroundTask.Builder()
      .id(getId())
      .url(getUrl())
      .description(getDescription())
      .origin(getOrigin())
      .funcName(getFuncName())
      .args(getArgs())
      .kwargs(getKwargs())
      .result(getResult())
      .timeout(getTimeout())
      .resultTtl(getResultTtl())
      .createdAt(getCreatedAt())
      .enqueuedAt(getEnqueuedAt())
      .startedAt(getStartedAt())
      .endedAt(getEndedAt())
      .workerName(getWorkerName())
      .position(getPosition())
      .status(getStatus())
      .meta(getMeta())
      .lastHeartbeat(getLastHeartbeat())
      .isFinished(getIsFinished())
      .isQueued(getIsQueued())
      .isFailed(getIsFailed())
      .isStarted(getIsStarted())
      .isDeferred(getIsDeferred())
      .isCanceled(getIsCanceled())
      .isScheduled(getIsScheduled())
      .isStopped(getIsStopped());
  }


}

